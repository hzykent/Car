<!DOCTYPE html>

<html>

<head>
	<title>Kent_car</title>

	<link rel="stylesheet" type="text/css" href="css/styles.css" />

	<script type="text/javascript" src="js/three.js"></script>
	<script type="text/javascript" src="js/stats.js"></script>
	<script type="text/javascript" src="js/physi.js"></script>
	<script type="text/javascript" src="js/quietriot.min.js"></script>
	<script type='text/javascript' src='js/OBJLoader.js'></script>
	<script type='text/javascript' src="js/Projector.js"></script>

	<script type="text/javascript">

		'use strict';

		Physijs.scripts.worker = 'js/physijs_worker.js';
		Physijs.scripts.ammo = 'ammo.js';

		var initScene, render,
			ground_material, car_material, wheel_material, wheel_geometry,
			projector, renderer, render_stats, physics_stats, scene, ground_geometry, ground, light, camera,
			car = {};

		var input;

		// ------------------------- ball var ----------------------------------
		var ball, score, degree, ball_display, ball_color;
		score = 0;
		degree = 0;
		var colors = [0xFF0FFF, 0xCCFF00, 0xFF000F, 0x996600, 0xFFFFFF];

		////////////// var for explode/////////
		var movementSpeed = 80;
		var totalObjects = 1000;
		var objectSize = 5;
		var sizeRandomness = 4000;
		var dirs = [];
		var parts = [];
		///////////////////////////

		// -------------------------- background var -----------------------------
		var cameraCube, sceneCube, textureCube, cubeMesh;

		initScene = function () {
			projector = new THREE.Projector;

			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.shadowMapEnabled = true;
			renderer.shadowMapSoft = true;
			document.getElementById('viewport').appendChild(renderer.domElement);
			renderer.autoClear = false;

			render_stats = new Stats();
			render_stats.domElement.style.position = 'absolute';
			render_stats.domElement.style.top = '0px';
			render_stats.domElement.style.zIndex = 100;
			document.getElementById('viewport').appendChild(render_stats.domElement);

			physics_stats = new Stats();
			physics_stats.domElement.style.position = 'absolute';
			physics_stats.domElement.style.top = '50px';
			physics_stats.domElement.style.zIndex = 100;
			document.getElementById('viewport').appendChild(physics_stats.domElement);

			// ---------------------------- Physijs Scene and camera ---------------------------------------------------------------------------
			scene = new Physijs.Scene;
			scene.setGravity(new THREE.Vector3(0, -30, 0));
			scene.addEventListener(
				'update',
				function () {
					scene.simulate(undefined, 2);
					physics_stats.update();
				}
			);

			camera = new THREE.PerspectiveCamera(
				35,
				window.innerWidth / window.innerHeight,
				1,
				1000
			);
			camera.position.set(0, 800, 0);
			camera.lookAt(scene.position);
			scene.add(camera);


			//------------------------------------------------------------- Light -------------------------------------------------------------------------
			light = new THREE.DirectionalLight(0xFFFFFF);
			light.position.set(300, 300, 300);
			light.target.position.copy(scene.position);
			light.castShadow = true;
			light.shadowCameraLeft = -500;
			light.shadowCameraTop = -500;
			light.shadowCameraRight = 500;
			light.shadowCameraBottom = 500;
			light.shadowCameraNear = 5;
			light.shadowCameraFar = 500;
			light.shadowBias = -.0001
			light.shadowMapWidth = light.shadowMapHeight = 4096;
			light.shadowDarkness = .7;
			scene.add(light);
			var ambient = new THREE.AmbientLight( 0x404040 ); // soft white light
			scene.add( ambient );



			//------------------------------------ background cube ---------------------------------------------------------------------------
			sceneCube = new THREE.Scene;

			cameraCube = new THREE.PerspectiveCamera(
				35,
				window.innerWidth / window.innerHeight,
				1,
				1000
			);
			cameraCube.position.set(0, 0, 0);
			cameraCube.lookAt(sceneCube.position);
			var r = "images/CloudyCrown_Midday_";
			var urls = [r + "Front.png", r + "Back.png",
			r + "Up.png", r + "Down.png",
			r + "Left.png", r + "Right.png"];
			textureCube = new THREE.CubeTextureLoader().load(urls);
			textureCube.format = THREE.RGBFormat;
			textureCube.mapping = THREE.CubeReflectionMapping;
			var cubeShader = THREE.ShaderLib["cube"];
			var cubeMaterial = new THREE.ShaderMaterial({
				fragmentShader: cubeShader.fragmentShader,
				vertexShader: cubeShader.vertexShader,
				uniforms: cubeShader.uniforms,
				depthWrite: false,
				side: THREE.BackSide
			});
			cubeMaterial.uniforms["tCube"].value = textureCube;
			cubeMesh = new THREE.Mesh(new THREE.BoxBufferGeometry(300, 300, 300), cubeMaterial);
			sceneCube.add(cubeMesh);
			cubeMesh.material = cubeMaterial;
			cubeMesh.visible = true;



			//------------------------------- ground -------------------------------------------------------------------------------------

			function addGround() {
				ground_material = Physijs.createMaterial(
					new THREE.MeshLambertMaterial({ map: THREE.ImageUtils.loadTexture('images/cartoon1.png') }),
					.8, // high friction
					.4 // low restitution
				);
				ground_material.map.wrapS = ground_material.map.wrapT = THREE.RepeatWrapping;
				ground_material.map.repeat.set(12, 12);
				var depth = 20;


				ground_geometry = new THREE.PlaneGeometry(500, 500, 50, 50);
				for (var i = 0; i < 20; i++) {
					for (var j = 50 + i * 100; j < 70 + i * 100; j++) {
						var face = ground_geometry.faces[j];
						var vertexa = ground_geometry.vertices[face.a];
						var vertexb = ground_geometry.vertices[face.b];
						var vertexc = ground_geometry.vertices[face.c];
						vertexa.z = -depth;
						vertexb.z = -depth;
						vertexc.z = -depth;
					}
				}
				for (var i = 5; i < 20; i++) {
					for (var j = 10 + i * 100; j < 40 + i * 100; j++) {
						var face = ground_geometry.faces[j];
						var vertexa = ground_geometry.vertices[face.a];
						var vertexb = ground_geometry.vertices[face.b];
						var vertexc = ground_geometry.vertices[face.c];
						vertexa.z = -depth;
						vertexb.z = -depth;
						vertexc.z = -depth;
					}
				}
				for (var i = 5; i < 20; i++) {
					for (var j = 80 + i * 100; j < 90 + i * 100; j++) {
						var face = ground_geometry.faces[j];
						var vertexa = ground_geometry.vertices[face.a];
						var vertexb = ground_geometry.vertices[face.b];
						var vertexc = ground_geometry.vertices[face.c];
						vertexa.z = -depth;
						vertexb.z = -depth;
						vertexc.z = -depth;
					}
				}
				for (var i = 25; i < 35; i++) {
					for (var j = 0 + i * 100; j < 5 + i * 100; j++) {
						var face = ground_geometry.faces[j];
						var vertexa = ground_geometry.vertices[face.a];
						var vertexb = ground_geometry.vertices[face.b];
						var vertexc = ground_geometry.vertices[face.c];
						vertexa.z = -depth;
						vertexb.z = -depth;
						vertexc.z = -depth;
					}
				}
				for (var i = 25; i < 35; i++) {
					for (var j = 0 + i * 100; j < 10 + i * 100; j++) {
						var face = ground_geometry.faces[j];
						var vertexa = ground_geometry.vertices[face.a];
						var vertexb = ground_geometry.vertices[face.b];
						var vertexc = ground_geometry.vertices[face.c];
						vertexa.z = -depth;
						vertexb.z = -depth;
						vertexc.z = -depth;
					}
				}
				for (var i = 25; i < 35; i++) {
					for (var j = 20 + i * 100; j < 55 + i * 100; j++) {
						var face = ground_geometry.faces[j];
						var vertexa = ground_geometry.vertices[face.a];
						var vertexb = ground_geometry.vertices[face.b];
						var vertexc = ground_geometry.vertices[face.c];
						vertexa.z = -depth;
						vertexb.z = -depth;
						vertexc.z = -depth;
					}
				}
				for (var i = 25; i < 35; i++) {
					for (var j = 85 + i * 100; j < 100 + i * 100; j++) {
						var face = ground_geometry.faces[j];
						var vertexa = ground_geometry.vertices[face.a];
						var vertexb = ground_geometry.vertices[face.b];
						var vertexc = ground_geometry.vertices[face.c];
						vertexa.z = -depth;
						vertexb.z = -depth;
						vertexc.z = -depth;
					}
				}
				for (var i = 25; i < 35; i++) {
					for (var j = 65 + i * 100; j < 75 + i * 100; j++) {
						var face = ground_geometry.faces[j];
						var vertexa = ground_geometry.vertices[face.a];
						var vertexb = ground_geometry.vertices[face.b];
						var vertexc = ground_geometry.vertices[face.c];
						vertexa.z = -depth;
						vertexb.z = -depth;
						vertexc.z = -depth;
					}
				}
				for (var i = 40; i < 45; i++) {
					for (var j = 50 + i * 100; j < 90 + i * 100; j++) {
						var face = ground_geometry.faces[j];
						var vertexa = ground_geometry.vertices[face.a];
						var vertexb = ground_geometry.vertices[face.b];
						var vertexc = ground_geometry.vertices[face.c];
						vertexa.z = -depth;
						vertexb.z = -depth;
						vertexc.z = -depth;
					}
				}
				for (var i = 40; i < 45; i++) {
					for (var j = 10 + i * 100; j < 40 + i * 100; j++) {
						var face = ground_geometry.faces[j];
						var vertexa = ground_geometry.vertices[face.a];
						var vertexb = ground_geometry.vertices[face.b];
						var vertexc = ground_geometry.vertices[face.c];
						vertexa.z = -depth;
						vertexb.z = -depth;
						vertexc.z = -depth;
					}
				}
				// for (var = 1400; i < 2601; i++) {
				// 	var vertex = ground_geometry.vertices[i];
				// 	//vertex.z = SimplexNoise.noise(vertex.x / 10, vertex.y / 10) * 5;
				// 	vertex.z = -100;
				// }
				ground_geometry.computeFaceNormals();
				ground_geometry.computeVertexNormals();

				ground = new Physijs.HeightfieldMesh(
					ground_geometry,
					ground_material,
					0, // mass
					50,
					50
				);
				ground.rotation.x = Math.PI / -2;
				ground.rotation.z = Math.PI;
				ground.receiveShadow = true;
				scene.add(ground);
			}
			
			
			//----------------------------------------- Car ---------------------------------------------------------------------------------

			function addCar() {
				var loader = new THREE.JSONLoader();

				loader.load("models/mustang.js", function (c, c_materials) {
					loader.load("models/mustang_wheel.js", function (wheel, wheel_materials) {
						var mesh = new Physijs.BoxMesh(
							c,
							new THREE.MeshFaceMaterial(c_materials)
						);
						mesh.position.y = 2;
						mesh.castShadow = mesh.receiveShadow = true;

						car = new Physijs.Vehicle(mesh, new Physijs.VehicleTuning(
							10.88,
							1.83,
							0.28,
							500,
							10.5,
							6000
						));
						car.mesh.name = 'car';
						car.mesh.position.set(240, 10, 240);
						car.mesh.rotation.y = Math.PI * 3 / 2;
						scene.add(car);

						var wheel_material = new THREE.MeshFaceMaterial(wheel_materials);

						for (var i = 0; i < 4; i++) {
							car.addWheel(
								wheel,
								wheel_material,
								new THREE.Vector3(
									i % 2 === 0 ? -1.6 : 1.6,
									-1,
									i < 2 ? 3.3 : -3.2
								),
								new THREE.Vector3(0, -1, 0),
								new THREE.Vector3(-1, 0, 0),
								0.5,
								0.7,
								i < 2 ? false : true
							);
						}

						input = {
							power: null, 
							direction: null,
							steering: 0
						};
						document.addEventListener('keydown', function (ev) {
							console.log("keydown");
							switch (ev.keyCode) {
								case 37: // left
									input.direction = 1;
									break;

								case 38: // forward
									input.power = true;
									break;

								case 39: // right
									input.direction = -1;
									break;

								case 40: // back
									input.power = false;
									break;
							}
						});
						document.addEventListener('keyup', function (ev) {
							switch (ev.keyCode) {
								case 37: // left
									input.direction = null;
									break;

								case 38: // forward
									input.power = null;
									break;

								case 39: // right
									input.direction = null;
									break;

								case 40: // back
									input.power = null;
									break;
							}
						});
					});
				});
				scene.addEventListener(
					'update',
					function () {

						if (input && car) {
							if (input.direction !== null) {
								input.steering = 0.2 * input.direction;
							} else {
								input.steering = 0;
							}
							car.setSteering(input.steering, 0);
							car.setSteering(input.steering, 1);

							if (input.power === true) {
								car.applyEngineForce(300);
							} else if (input.power === false) {
								car.setBrake(20, 0);
								car.setBrake(20, 1);
								car.setBrake(20, 2);
								car.setBrake(20, 3);
							} else {
								car.applyEngineForce(-300);

							}
						}

						scene.simulate(undefined, 2);
						physics_stats.update();
					}
				);
			}


			// ---------------------------------------------- JSON object Loading-------------------------------------------------------------
			// cloud
			function getRandomInt(max) {
				return Math.floor(Math.random() * Math.floor(max));
			}

			function addObject() {
				for (var i = 0; i < 10; i++) {
					var loader = new THREE.ObjectLoader();
					loader.load("objects/island-cloud-mod.json", function (object) {
						var cloud = new Physijs.BoxMesh(object.children[0].children[0].geometry, object.children[0].children[0].material, 0);
						cloud.castShadow = true;
						//cloud.receiveShadow = true;
						cloud.scale.set(0.1, 0.1, 0.1);
						var ran_x = getRandomInt(500) - 250;
						var ran_z = getRandomInt(500) - 250;
						cloud.position.set(ran_x, 20, ran_z);
						scene.add(cloud);
					});
				}

				for (var i = 0; i < 10; i++) {
					var loader = new THREE.ObjectLoader();
					loader.load("objects/island-cloud-c.json", function (object) {
						var cloud = new Physijs.BoxMesh(object.children[0].children[0].geometry, object.children[0].children[0].material, 0);
						cloud.castShadow = true;
						//cloud.receiveShadow = true;
						cloud.scale.set(0.5, 0.5, 0.5);
						var ran_x = getRandomInt(500) - 250;
						var ran_z = getRandomInt(500) - 250;
						cloud.position.set(ran_x, 20, ran_z);
						cloud.rotation.x = Math.PI / 2;
						scene.add(cloud);
					});
				}


				// 	// trees
				for (var i = 0; i < 10; i++) {
					var ran_x = getRandomInt(495) - 245;
					var ran_z = getRandomInt(495) - 245;
					var loader = new THREE.ObjectLoader();
					loader.load("objects/tree-toon.json", function (object) {
						var tree = new Physijs.BoxMesh(object.children[3].geometry, object.children[3].material, 0);
						tree.castShadow = true;
						tree.receiveShadow = true;
						tree.scale.set(1, 12, 1);
						tree.position.set(ran_x, 10, ran_z);
						scene.add(tree);
					});
					var loader = new THREE.ObjectLoader();
					loader.load("objects/tree-toon.json", function (object) {
						var tree = new Physijs.BoxMesh(object.children[2].geometry, object.children[2].material, 0);
						tree.castShadow = true;
						tree.receiveShadow = true;
						tree.scale.set(8, 8, 8);
						tree.position.set(ran_x, 18, ran_z);
						tree.rotation.x = Math.PI;
						scene.add(tree);
					});
					var loader = new THREE.ObjectLoader();
					loader.load("objects/tree-toon.json", function (object) {
						var tree = new Physijs.BoxMesh(object.children[1].geometry, object.children[1].material, 0);
						tree.castShadow = true;
						tree.receiveShadow = true;
						tree.scale.set(6, 6, 6);
						tree.position.set(ran_x, 25, ran_z);
						tree.rotation.x = Math.PI;
						scene.add(tree);
					});
					var loader = new THREE.ObjectLoader();
					loader.load("objects/tree-toon.json", function (object) {
						var tree = new Physijs.BoxMesh(object.children[0].geometry, object.children[0].material, 0);
						tree.castShadow = true;
						tree.receiveShadow = true;
						tree.scale.set(4, 4, 4);
						tree.position.set(ran_x, 30, ran_z);
						tree.rotation.x = Math.PI;
						scene.add(tree);
					});
				}

				// var loader = new THREE.ObjectLoader();
				// loader.load("objects/tree-toon.json", function (object) {
				// 	var tree = new Physijs.BoxMesh(object.children[3].geometry, object.children[3].material, 0);
				// 	tree.castShadow = true;
				// 	tree.receiveShadow = true;
				// 	tree.scale.set(1, 12, 1);
				// 	tree.position.set(0, 10, 110);
				// 	scene.add(tree);
				// });
				// var loader = new THREE.ObjectLoader();
				// loader.load("objects/tree-toon.json", function (object) {
				// 	var tree = new Physijs.BoxMesh(object.children[2].geometry, object.children[2].material, 0);
				// 	tree.castShadow = true;
				// 	tree.receiveShadow = true;
				// 	tree.scale.set(8, 8, 8);
				// 	tree.position.set(0, 18, 110);
				// 	tree.rotation.x = Math.PI;
				// 	scene.add(tree);
				// });
				// var loader = new THREE.ObjectLoader();
				// loader.load("objects/tree-toon.json", function (object) {
				// 	var tree = new Physijs.BoxMesh(object.children[1].geometry, object.children[1].material, 0);
				// 	tree.castShadow = true;
				// 	tree.receiveShadow = true;
				// 	tree.scale.set(6, 6, 6);
				// 	tree.position.set(0, 25, 110);
				// 	tree.rotation.x = Math.PI;
				// 	scene.add(tree);
				// });
				// var loader = new THREE.ObjectLoader();
				// loader.load("objects/tree-toon.json", function (object) {
				// 	var tree = new Physijs.BoxMesh(object.children[0].geometry, object.children[0].material, 0);
				// 	tree.castShadow = true;
				// 	tree.receiveShadow = true;
				// 	tree.scale.set(4, 4, 4);
				// 	tree.position.set(0, 30, 110);
				// 	tree.rotation.x = Math.PI;
				// 	scene.add(tree);
				// });
			}


			// --------------------------------------- ball ---------------------------------------

			function addBall() {
				// ball_color = colors[Math.round(Math.random() * colors.length)];
				ball_color = 0xF9A602;
				var ball_material = Physijs.createMaterial(
					new THREE.MeshStandardMaterial({ color: ball_color, shading: THREE.FlatShading }),
					.8,
					.9);
				// var ball_geometry = new THREE.SphereGeometry(2, 16, 16);
				var ball_geometry = new THREE.CylinderGeometry(3, 3, 1, 16, 1, false)
				ball_display = new THREE.Mesh(ball_geometry, ball_material, 10)
				// ball_display = new Physijs.SphereMesh(ball_geometry, ball_material, 0);
				ball_display.castShadow = true;
				ball = new Physijs.SphereMesh(ball_geometry, ball_material, 10);
				// ball = new THREE.Mesh(ball_geometry, ball_material, 0);
				ball.castShadow = true;
				releaseBall();
				ball.visible = false;
				scene.add(ball_display)
				scene.add(ball);
				// ball.setDamping(0, 0.9);
				ball.addEventListener('collision', onCollision);
			}
			function releaseBall() {
				var range = 10 + Math.random() * 30;
				ball.position.y = 10;
				ball.position.x = ((2 * Math.floor(Math.random() * 2)) - 1) * range;
				ball.position.z = ((2 * Math.floor(Math.random() * 2)) - 1) * range;
				// ball.position.x = car.body.position.x - 10;
				// ball.position.z = car.body.position.z;
				ball_display.position.x = ball.position.x;
				ball_display.position.y = 4;
				ball_display.position.z = ball.position.z;
				ball.__dirtyPosition = true;//force new position 
				ball_display.__dirtyPosition = true;
				// You also need to cancel the object's velocity 
				// ball.setLinearVelocity(new THREE.Vector3(0, 0, 0));
				// ball.setAngularVelocity(new THREE.Vector3(0.1, 0, 0));
			}
			function removeBall() {
				parts.push(new ExplodeAnimation(ball.position.x, ball.position.y, ball.position.z));
				scene.remove(ball);
				scene.remove(ball_display)
				addBall();
			}
			function onCollision(other_object, linear_velocity, angular_velocity) {
				// console.log(other_object);
				// console.log(other_object.name);
				if (other_object.name === "car") {
					console.log("Collision");
					score++;
					removeBall();
					document.getElementById("score").innerHTML = "Your Score is " + score.toString();
					scene.remove(ground);
					addGround();
				}
			}
			function ExplodeAnimation(x, y, z) {
				var geometry = new THREE.Geometry();
				for (var i = 0; i < totalObjects; i++) {
					var vertex = new THREE.Vector3();
					vertex.x = x;
					vertex.y = y;
					vertex.z = z;

					geometry.vertices.push(vertex);
					dirs.push({
						x: (Math.random() * movementSpeed) - (movementSpeed / 2),
						// y: (Math.random() * movementSpeed) - (movementSpeed / 2),
						y: 0,
						z: (Math.random() * movementSpeed) - (movementSpeed / 2)
					});
				}
				var material = new THREE.PointsMaterial({ size: objectSize, color: ball_color });
				var particles = new THREE.Points(geometry, material);

				this.object = particles;
				this.status = true;

				this.xDir = (Math.random() * movementSpeed) - (movementSpeed / 2);
				// this.yDir = (Math.random() * movementSpeed) - (movementSpeed / 2);
				this.yDir = 0;
				this.zDir = (Math.random() * movementSpeed) - (movementSpeed / 2);

				scene.add(this.object);

				this.update = function () {
					if (this.status == true) {
						var pCount = totalObjects;
						while (pCount--) {
							var particle = this.object.geometry.vertices[pCount]
							particle.y += dirs[pCount].y;
							particle.x += dirs[pCount].x;
							particle.z += dirs[pCount].z;
						}
						this.object.geometry.verticesNeedUpdate = true;
					}
				}
			}

			addBall();
			addObject();
			addCar();
			addGround();
			requestAnimationFrame(render);
			scene.simulate();
		};


		function camera_update() {
			//var relativeCameraOffset = new THREE.Vector3(100 ,100 ,0);
			var relativeCameraOffset = new THREE.Vector3(0, 50, -100);
			var cameraOffset = relativeCameraOffset.applyMatrix4(car.mesh.matrixWorld);
			camera.position.x = cameraOffset.x;
			camera.position.y = cameraOffset.y;
			camera.position.z = cameraOffset.z;
			camera.lookAt(car.mesh.position);
			cubeMesh.position.x = car.mesh.position.x;
			cubeMesh.position.y = car.mesh.position.y;
			cubeMesh.position.z = car.mesh.position.z;
			cameraCube.position.x = cameraOffset.x;
			cameraCube.position.y = cameraOffset.y;
			cameraCube.position.z = cameraOffset.z;
			cameraCube.lookAt(car.mesh.position);
		}

		render = function () {
			requestAnimationFrame(render);
			renderer.clear();
			renderer.render(sceneCube, cameraCube);
			renderer.render(scene, camera);

			// make the ball rotation
			ball_display.rotation.z = 0.5 * Math.PI;
			ball_display.rotation.y += 0.05 * Math.PI;
			ball.rotation.z = 0.5 * Math.PI;
			ball.rotation.y += 0.05 * Math.PI;
			// console.log("rotate:", ball.rotation.x)
			var pCount = parts.length;
			while (pCount--) {
				// console.log("update");
				parts[pCount].update();
			}

			render_stats.update();
			camera_update();
		};

		window.onload = initScene;

	</script>
</head>

<body>
	<div id="heading">
		<h1>Constraints, Car - <a href="http://chandlerprall.github.com/Physijs/">Physijs</a></h1>
		<p>Use the arrow keys to drive around.</p>
	</div>
	<div id="viewport"></div>

	<script type="text/javascript">

		var _gaq = _gaq || [];
		_gaq.push(['_setAccount', 'UA-31289553-1']);
		_gaq.push(['_trackPageview']);

		(function () {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = "js/ga.js";
			var s = document.getElementsByTagName('script')[0];
			s.parentNode.insertBefore(ga, s);
		})();

	</script>
</body>

</html>